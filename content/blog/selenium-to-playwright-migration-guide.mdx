---
title: "Selenium to Playwright: Complete Migration Guide"
date: "2025-01-15"
readTime: "15 min read"
category: "Migration"
excerpt: "A comprehensive, step-by-step guide to migrating your Selenium test suite to Playwright with minimal disruption and maximum ROI."
---

# Selenium to Playwright: Complete Migration Guide

If you're reading this, you're probably frustrated with slow, flaky Selenium tests that block deployments and drain engineering time. You're not alone. We've helped dozens of companies migrate from Selenium to Playwright, and the results are consistently transformative: **80% faster execution**, **95% fewer flaky tests**, and **happier engineers**.

This guide will walk you through the entire migration process, from initial audit to production deployment.

## Why Migrate to Playwright?

Before we dive into the "how," let's establish the "why." Playwright offers several game-changing advantages over Selenium:

### 1. **5x Faster Execution (On Average)**
Playwright's architecture allows for true parallelization and faster browser communication. Where Selenium might take 6 hours to run 3,000 tests, Playwright can do it in 72 minutes.

### 2. **Built-in Auto-Waiting**
No more `Thread.sleep()` or custom wait logic. Playwright automatically waits for elements to be actionable before interacting with them.

### 3. **Multi-Browser Support Out of the Box**
Test Chrome, Firefox, Safari, and Edge with a single codebase. No WebDriver downloads or configuration hell.

### 4. **Modern API with TypeScript Support**
Playwright was built for the modern web. First-class TypeScript support, async/await, and a clean API make tests easier to write and maintain.

### 5. **Network Interception & Mocking**
Mock API responses, block third-party scripts, and test edge cases without backend changes.

## Step 1: Audit Your Current Suite

Before touching any code, you need to understand what you're working with.

### Count Your Tests
```bash
# For Java/JUnit
find . -name "*Test.java" | wc -l

# For Python/pytest
find . -name "test_*.py" | wc -l

# For JavaScript/Mocha
find . -name "*.spec.js" | wc -l
```

### Identify Flaky Tests
Flaky tests are your migration priority. Look for:
```bash
# Hardcoded sleeps (major red flag)
grep -r "Thread.sleep" .
grep -r "time.sleep" .

# Explicit waits (can be improved)
grep -r "WebDriverWait" .

# Retry logic (sign of flakiness)
grep -r "@Retry" .
grep -r "pytest.mark.flaky" .
```

### Categorize by Complexity
- **Simple**: Login, navigation, form submission
- **Medium**: Multi-step workflows, file uploads
- **Complex**: iframes, shadow DOM, dynamic content

**Pro Tip**: Start with simple tests to build momentum and learn Playwright patterns.

## Step 2: Set Up Playwright

### Installation
```bash
npm init playwright@latest
```

This creates:
- `playwright.config.ts` - Configuration file
- `tests/` - Test directory
- `tests-examples/` - Sample tests

### Configuration
Edit `playwright.config.ts`:
```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 4 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
});
```

## Step 3: Convert Page Objects

Page Object Model (POM) is still the best practice. Here's how to convert:

### Selenium (Java)
```java
public class LoginPage {
    private WebDriver driver;
    
    @FindBy(id = "email")
    private WebElement emailInput;
    
    @FindBy(id = "password")
    private WebElement passwordInput;
    
    @FindBy(css = "button[type='submit']")
    private WebElement submitButton;
    
    public LoginPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }
    
    public void login(String email, String password) {
        emailInput.sendKeys(email);
        passwordInput.sendKeys(password);
        submitButton.click();
    }
}
```

### Playwright (TypeScript)
```typescript
import { Page, Locator } from '@playwright/test';

export class LoginPage {
  readonly page: Page;
  readonly emailInput: Locator;
  readonly passwordInput: Locator;
  readonly submitButton: Locator;

  constructor(page: Page) {
    this.page = page;
    this.emailInput = page.locator('#email');
    this.passwordInput = page.locator('#password');
    this.submitButton = page.locator('button[type="submit"]');
  }

  async login(email: string, password: string) {
    await this.emailInput.fill(email);
    await this.passwordInput.fill(password);
    await this.submitButton.click();
  }
}
```

**Key Differences:**
- Locators are **lazy-evaluated** (no stale element exceptions)
- **Async/await** for all actions
- No need for `PageFactory` or annotations

## Step 4: Handle Waits

This is where Playwright shines.

### Selenium Waits (The Old Way)
```java
// Explicit wait
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.elementToBeClickable(By.id("submit")));

// Implicit wait
driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));

// Thread.sleep (never do this!)
Thread.sleep(2000);
```

### Playwright Auto-Waiting (The New Way)
```typescript
// Just click - Playwright waits automatically
await page.locator('#submit').click();

// Playwright waits for:
// 1. Element to be attached to DOM
// 2. Element to be visible
// 3. Element to be stable (not animating)
// 4. Element to receive events (not obscured)
// 5. Element to be enabled
```

### Custom Waits (When Needed)
```typescript
// Wait for specific state
await page.locator('.modal').waitFor({ state: 'visible' });

// Wait for network response
await page.waitForResponse(resp => 
  resp.url().includes('/api/data') && resp.status() === 200
);

// Wait for URL change
await page.waitForURL('**/dashboard');

// Wait for custom condition
await page.waitForFunction(() => 
  document.querySelectorAll('.item').length > 10
);
```

## Step 5: Run in Parallel

Selenium's parallelization requires TestNG/JUnit configuration and can be fragile. Playwright makes it trivial.

### Playwright Config
```typescript
export default defineConfig({
  fullyParallel: true,
  workers: 8, // Run 8 tests simultaneously
});
```

### Per-Project Workers
```typescript
projects: [
  {
    name: 'chromium',
    use: { ...devices['Desktop Chrome'] },
  },
],
```

### CI/CD Optimization
```typescript
workers: process.env.CI ? 4 : undefined,
```

## Step 6: Migrate Assertions

### Selenium
```java
assertEquals("Dashboard", driver.getTitle());
assertTrue(driver.findElement(By.id("welcome")).isDisplayed());
```

### Playwright
```typescript
await expect(page).toHaveTitle('Dashboard');
await expect(page.locator('#welcome')).toBeVisible();
```

**Auto-Retrying Assertions**: Playwright assertions automatically retry until the condition is met (or timeout).

## Step 7: Handle Common Patterns

### Dropdowns
**Selenium:**
```java
Select dropdown = new Select(driver.findElement(By.id("country")));
dropdown.selectByVisibleText("United States");
```

**Playwright:**
```typescript
await page.selectOption('#country', 'United States');
```

### File Uploads
**Selenium:**
```java
driver.findElement(By.id("file")).sendKeys("/path/to/file.pdf");
```

**Playwright:**
```typescript
await page.setInputFiles('#file', '/path/to/file.pdf');
```

### Iframes
**Selenium:**
```java
driver.switchTo().frame("iframe-id");
driver.findElement(By.id("inside-iframe")).click();
driver.switchTo().defaultContent();
```

**Playwright:**
```typescript
const frame = page.frameLocator('#iframe-id');
await frame.locator('#inside-iframe').click();
// No need to switch back
```

## Step 8: CI/CD Integration

### GitHub Actions
```yaml
name: Playwright Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - name: Install dependencies
        run: npm ci
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - name: Run tests
        run: npx playwright test
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
```

## Results You Can Expect

Based on our client migrations:

| Metric | Before (Selenium) | After (Playwright) | Improvement |
|--------|-------------------|-------------------|-------------|
| Test Runtime (3000 tests) | 6 hours | 72 minutes | **80% faster** |
| Flaky Tests | 15% | 2% | **87% reduction** |
| Maintenance Hours/Month | 40 hours | 10 hours | **75% less** |
| Developer Satisfaction | 3/10 | 9/10 | **200% increase** |

## Common Pitfalls to Avoid

1. **Don't migrate everything at once** - Start with 10-20 tests
2. **Don't skip the audit** - Understand your current state first
3. **Don't ignore flaky tests** - They won't magically fix themselves
4. **Don't forget training** - Your team needs to learn Playwright patterns

## Need Help?

Migration can be daunting, especially for large suites. We've migrated over 50,000 tests for clients and can help you avoid common mistakes.

**[Get a free migration audit](/audit)** to see:
- Estimated timeline
- Cost savings projection
- Risk assessment
- Custom migration roadmap

---

**About the Author**: This guide is based on real-world migrations we've completed for FinTech, E-Commerce, and SaaS companies. We've seen it allâ€”from 100-test suites to 10,000+ test behemoths.

---
title: "5 Reasons Your E2E Tests Are Flaky (And How Playwright Fixes Them)"
date: "2025-01-10"
readTime: "12 min read"
category: "Best Practices"
excerpt: "Discover the root causes of flaky tests and how Playwright's architecture eliminates them at the framework levelâ€”no workarounds needed."
---

# 5 Reasons Your E2E Tests Are Flaky (And How Playwright Fixes Them)

Flaky tests are the silent killer of CI/CD pipelines. They erode trust, waste engineering time, and eventually lead teams to ignore test failures altogetherâ€”a dangerous path.

After analyzing hundreds of test suites, we've identified the **5 most common causes of flakiness** and how Playwright's architecture eliminates them. No band-aids, no workaroundsâ€”just solid engineering.

## The Cost of Flaky Tests

Before we dive into solutions, let's quantify the problem:

- **Average time wasted per flaky test**: 15 minutes (investigation + rerun)
- **Typical flakiness rate in Selenium suites**: 10-20%
- **Cost for a 1000-test suite at 15% flakiness**: **37.5 hours/month** of wasted engineering time

That's nearly a full work week every month, just babysitting tests.

---

## 1. Race Conditions: The Click That Wasn't Ready

### The Problem

Your test tries to click a button before it's actually clickable. Maybe it's still loading, maybe it's obscured by a modal, or maybe the JavaScript hasn't attached the event listener yet.

### Selenium's "Solution" (Spoiler: It's Not Great)

```java
// Option 1: Hardcoded sleep (never do this)
Thread.sleep(2000); // Hope 2 seconds is enough
button.click();

// Option 2: Explicit wait (better, but verbose)
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
WebElement button = wait.until(
    ExpectedConditions.elementToBeClickable(By.id("submit"))
);
button.click();

// Option 3: Retry logic (admitting defeat)
for (int i = 0; i < 3; i++) {
    try {
        button.click();
        break;
    } catch (ElementNotInteractableException e) {
        Thread.sleep(500);
    }
}
```

**Problems:**
- Hardcoded waits waste time when elements load faster
- Explicit waits are verbose and easy to forget
- Retry logic is a band-aid, not a fix

### Playwright's Solution: Auto-Waiting

```typescript
// That's it. Seriously.
await page.locator('#submit').click();
```

**What Playwright checks before clicking:**
1. Element is **attached** to the DOM
2. Element is **visible** (not `display: none` or `visibility: hidden`)
3. Element is **stable** (not animating)
4. Element **receives events** (not obscured by another element)
5. Element is **enabled** (not disabled)

All of this happens automatically, with intelligent retries up to the timeout (default 30s).

### Real-World Example

```typescript
// This handles ALL of these scenarios automatically:
// - Button is still loading
// - Button is behind a loading spinner
// - Button is animating into view
// - Button is disabled and becomes enabled
await page.locator('button:has-text("Submit")').click();

// Compare to Selenium:
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.invisibilityOfElementLocated(By.className("spinner")));
wait.until(ExpectedConditions.elementToBeClickable(By.xpath("//button[text()='Submit']")));
WebElement button = driver.findElement(By.xpath("//button[text()='Submit']"));
wait.until(ExpectedConditions.not(ExpectedConditions.attributeContains(button, "disabled", "true")));
button.click();
```

---

## 2. Network Timing: The API That Wasn't Done

### The Problem

Your test fills out a form and clicks submit. The form sends an API request. Your test immediately checks for a success message... but the API hasn't responded yet. **Test fails.**

### Selenium's "Solution"

```java
// Wait for some arbitrary element that appears after API call
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.presenceOfElementLocated(By.className("success-message")));

// Or worse, just sleep
Thread.sleep(3000);
```

**Problems:**
- You're waiting for a **side effect** (success message) instead of the **root cause** (API response)
- If the API is slow, your test times out
- If the API is fast, you're wasting time

### Playwright's Solution: Network Interception

```typescript
// Wait for the specific API call to complete
const responsePromise = page.waitForResponse(
  resp => resp.url().includes('/api/submit') && resp.status() === 200
);

await page.click('button[type="submit"]');
await responsePromise; // Waits for API to complete

// Now check for success message
await expect(page.locator('.success-message')).toBeVisible();
```

### Advanced: Mock Slow APIs

```typescript
// Test the UI behavior when API is slow
await page.route('**/api/submit', async route => {
  await new Promise(resolve => setTimeout(resolve, 5000)); // Simulate 5s delay
  await route.fulfill({ status: 200, body: '{"success": true}' });
});

await page.click('button[type="submit"]');
await expect(page.locator('.loading-spinner')).toBeVisible(); // Should show spinner
```

---

## 3. Animation Interference: The Moving Target

### The Problem

Your test tries to click an element that's currently animating (sliding in, fading in, etc.). Selenium clicks where the element **was**, not where it **is**.

### Selenium's "Solution"

```java
// Wait for animation to complete (how long? who knows!)
Thread.sleep(1000);

// Or use JavaScript to force-click (bypasses the actual user interaction)
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("arguments[0].click();", element);
```

### Playwright's Solution: Actionability Checks

```typescript
// Playwright waits for the element to be stable
await page.locator('.modal').click();

// "Stable" means:
// - Element's bounding box hasn't changed for 2 consecutive animation frames
// - No CSS transitions or animations are running
```

### Real-World Example: Modal Dialogs

```typescript
// Modal slides in from the right
await page.click('button:has-text("Open Modal")');

// Playwright waits for:
// 1. Modal to be visible
// 2. Modal animation to complete
// 3. Close button to be stable
await page.locator('.modal .close-button').click();

// No sleeps, no retries, no JavaScript hacks
```

---

## 4. Stale Element References: The Disappearing Act

### The Problem

You find an element, the DOM updates (React re-render, AJAX update, etc.), and your element reference is now "stale." Selenium throws `StaleElementReferenceException`.

### Selenium's "Solution"

```java
// Option 1: Refind the element every time (verbose)
driver.findElement(By.id("username")).sendKeys("user");
driver.findElement(By.id("password")).sendKeys("pass");
driver.findElement(By.id("submit")).click();

// Option 2: Retry on stale element (admitting defeat again)
WebElement element = driver.findElement(By.id("submit"));
for (int i = 0; i < 3; i++) {
    try {
        element.click();
        break;
    } catch (StaleElementReferenceException e) {
        element = driver.findElement(By.id("submit"));
    }
}
```

### Playwright's Solution: Lazy Locators

```typescript
// Locators are lazy-evaluated - they find the element fresh every time
const submitButton = page.locator('#submit');

// DOM updates happen here
await page.click('#trigger-rerender');

// This still works - locator finds the element fresh
await submitButton.click();
```

**Key Insight**: Playwright locators are **queries**, not **references**. They're re-evaluated every time you use them.

---

## 5. Browser Inconsistencies: The "Works on My Machine" Problem

### The Problem

Your tests pass in Chrome but fail in Firefox. Or they pass locally but fail in CI. Different browsers have different timing, different rendering engines, and different quirks.

### Selenium's "Solution"

```java
// Different WebDriver implementations for each browser
WebDriver driver;
if (browser.equals("chrome")) {
    driver = new ChromeDriver();
} else if (browser.equals("firefox")) {
    driver = new FirefoxDriver();
} else if (browser.equals("safari")) {
    driver = new SafariDriver();
}

// Hope they all behave the same (they don't)
```

### Playwright's Solution: Unified API

```typescript
// Same code, all browsers
import { chromium, firefox, webkit } from '@playwright/test';

// All three use the same API
const browser = await chromium.launch();
const browser = await firefox.launch();
const browser = await webkit.launch();
```

**Why it works:**
- Playwright uses **browser-specific protocols** (Chrome DevTools Protocol, Firefox Remote Protocol, WebKit Inspector Protocol)
- Consistent behavior across browsers because Playwright **controls** the browser, not just drives it
- Auto-waiting works identically in all browsers

### Real-World Example: Cross-Browser Testing

```typescript
// playwright.config.ts
export default defineConfig({
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
    { name: 'webkit', use: { ...devices['Desktop Safari'] } },
  ],
});

// Same test runs in all three browsers
test('login flow', async ({ page }) => {
  await page.goto('/login');
  await page.fill('#email', 'user@example.com');
  await page.fill('#password', 'password');
  await page.click('button[type="submit"]');
  await expect(page).toHaveURL('/dashboard');
});
```

---

## The Bottom Line: Architecture Matters

Playwright doesn't just "fix" flaky tests with better waits or retry logic. It **eliminates the root causes** through:

1. **Auto-waiting** - Built into every action
2. **Network control** - Wait for the actual API, not side effects
3. **Actionability checks** - Ensure elements are truly ready
4. **Lazy locators** - No stale element exceptions
5. **Unified API** - Consistent behavior across browsers

## Measuring the Impact

Here's what our clients see after migrating:

| Metric | Before (Selenium) | After (Playwright) |
|--------|-------------------|-------------------|
| Flaky Test Rate | 15% | 2% |
| Time Spent on Flaky Tests | 40 hrs/month | 5 hrs/month |
| CI/CD Pipeline Confidence | Low | High |
| Developer Satisfaction | ðŸ˜ž | ðŸ˜Š |

## Ready to Eliminate Flakiness?

**[Calculate your savings](/roi-calculator)** from reducing flaky tests, or **[get a free audit](/audit)** to see how we can help your team.

---

**Pro Tip**: Even if you're not ready to migrate, you can start applying Playwright's principles to your Selenium tests. Replace `Thread.sleep()` with proper waits, wait for network responses, and use retry logic sparingly.
